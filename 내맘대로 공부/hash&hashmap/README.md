- [Hash](#hash)
  - [Hash function 과 Hasing](#hash-function-과-hasing)
  - [헤시 충돌 처리 방법](#헤시-충돌-처리-방법)
    - [체이닝](#체이닝)
    - [개방 주소법(Open Addressing)](#개방-주소법open-addressing)
    - [더블 해싱](#더블-해싱)
  - [그렇다면 Hash와 HashMap의 차이는 뭘까?](#그렇다면-hash와-hashmap의-차이는-뭘까)
    - [헤시](#헤시)
    - [헤시맵](#헤시맵)
  - [요약](#요약)
  - [헤시맵의 삽입, 검색, 삭제연산](#헤시맵의-삽입-검색-삭제연산)
  - [헤시맵의 성능과 사용 사례](#헤시맵의-성능과-사용-사례)
  - [헤시 테이블과 버킷구조](#헤시-테이블과-버킷구조)
  - [헤시 셋(HashSet)과 헤시맵(HashMap)의 차이점](#헤시-셋hashset과-헤시맵hashmap의-차이점)
  - [헤시 함수의 품질과 안정성](#헤시-함수의-품질과-안정성)
  - [자바스크립트에서의 Map과 Object 의 차이점](#자바스크립트에서의-map과-object-의-차이점)
    - [Map:](#map)
    - [객체(Object):](#객체object)
  - [사용예시 Map](#사용예시-map)
    - [기본 js 코드](#기본-js-코드)
    - [활용](#활용)

# Hash

- 해시는 임의의 크기의 데이터를 고정된 크기의 값으로 변환하는 프로세스이다.
- 이렇게 생성된 고정된 크기의 값은 해시 값 또는 해시 코드로 알려진다.
- 해시의 주요목적은 데이터를 빠르게 검색하고 비교하기 위해 데이터를 인덱싱 하는데 사용된다.
- 해시 값은 원본 데이터와 상호 연관성이 없고 , 동일한 데이터에 대해서 항상 동일한 해시 값을 생성해야한다.

## Hash function 과 Hasing

- 헤시 함수는 헤시 값을 계산하기 위한 함수로, 임의의 데이터를 입력으로 받아 고정된 크기의 해시값을 반환한다.
- 헤싱은 데이터를 해시 함수를 사용해서 해시 값으로 변환하는 프로세스를 의미한다.
- 동일한 입력에 대해 항상 동일한 해시 값을 생성하고 다른 입력은 다른 해시값을 생성해야한다.
- 해시 함수는 빠르게 계산되야하고 **해시 충돌**을 최소화 해야한다.

## 헤시 충돌 처리 방법

- 헤시 충돌은 두 개 이상의 다른 데이터가 동일한 해시 값을 생성할 때에 발생한다.
- 해시 충돌을 해결하기 위한 주요방법

### 체이닝

- 해시 테이블의 각 슬롯에 링크드 리스트 또는 배열을 사용해서 충돌된 데이터를 저장한다.

### 개방 주소법(Open Addressing)

- 충돌이 발생하면 다른 슬롯에 데이터를 저장하거나 비어있는 슬롯을 찾아 저장한다. 각 알고리즘을 이용해 해시 충돌을 해결

1. 선형 탐사(Linear Probing)

- 선형 탐사는 충돌 발생 시 동일한 해시 테이블 슬롯에서 다음 슬롯으로 이동하여 다음 슬롯이 비어 있을때 데이터를 저장
- 충돌이 해결될 때까지 인접한 슬롯을 순차적으로 검색
- 선형 탐사는 간단하고 구현이 용이하지만, _클러스터링_ 문제(한 슬롯에 데이터가 연속으로 쌓이는 현상)를 일으킬수있다.

2.  이차 탐사(Quadratic Probing),

- 이차 탐사는 충돌 발생시 충돌 슬롯에서 시작하여 규칙에 따라 제곱 수만큼 슬롯을 이동하여 다음 슬롯을 검색하고 , 빈 슬롯을 찾을 때까지 반복한다.
- 이차 탐사는 선형 탐사의 클러스터링 문제를 완화시킬수있다.
- 선형탐사 보단 조금 복잡하지만 , 성능면에선 효과적이다.

3. 랜덤화 탐사(Randomized Probing)

- 랜덤화 탐사는 충돌 발생 시 무작위로 슬롯을 선택하여 데이터를 저장한다.
- 무작위성을 통해 클러스터링 문제를 방지하고, 좋은 분산을 유지한다.
- 랜덤화 탐사는 구현이 복잡하고, 무작위 수 발생이 필요하므로 성능 측면에서도 복잡할수 있다.

### 더블 해싱

- 해시 충돌이 발생한 경우 , 두번째 해시 함수를 사용해서 다른 슬롯을 찾아 저장한다.

## 그렇다면 Hash와 HashMap의 차이는 뭘까?

### 헤시

- 해시는 데이터를 고정된 크기의 값으로 변환하는 프로세스를 나타낸다 예) 헤시함수
- 헤시 함수를 사용해서 데이터를 헤시값 또는 헤시코드로 변환
- 헤시함수는 동일한 입력에 대해 항상 동일한 헤시 값을 생성하고, 다른 입력에 대해 다른 헤시 값을 생성해야한다.
- 주로 데이터 검색 및 무결성확인에 사용된다.

```js
// 해시 함수를 사용하여 문자열을 해시 값으로 변환
function hashFunction(key) {
  let hash = 0;
  for (let i = 0; i < key.length; i++) {
    hash = (hash + key.charCodeAt(i)) % 100; // 예시로 100개의 슬롯을 가진 해시 테이블을 가정
  }
  return hash;
}

const key1 = "apple";
const key2 = "banana";

const hash1 = hashFunction(key1);
const hash2 = hashFunction(key2);

console.log("Hash of key1 (apple):", hash1); // 예시 출력: Hash of key1 (apple): 48
console.log("Hash of key2 (banana):", hash2); // 예시 출력: Hash of key2 (banana): 73
```

### 헤시맵

- 헤시맵은 헤시 테이블 기반의 데이터 구조로 `key-value`쌍을 저장하고 검색하는데 사용된다.
- 각 key는 해시 함수를 사용해서 해시값으로 변환되고 해당 해시 값을 인덱스로 사용하여 값을 찾는다.
- 헤시맵은 키-값 쌍을 효율적으로 저장하고 검색 하는데에 사용된다.
- 주로 데이터 구조와 알고리즘의 일부로 사용

```js
// 간단한 해시맵 구현
class HashMap {
  constructor() {
    this.data = {};
  }

  put(key, value) {
    this.data[key] = value;
  }

  get(key) {
    return this.data[key];
  }
}

const myMap = new HashMap();
myMap.put("apple", 10);
myMap.put("banana", 5);

console.log("Value for key 'apple':", myMap.get("apple")); // 예시 출력: Value for key 'apple': 10
console.log("Value for key 'banana':", myMap.get("banana")); // 예시 출력: Value for key 'banana': 5
```

## 요약

> 간단히 말하면 해시맵은 헤시 값들을 관리하는 데이터구조다. 즉, 해시맵 안에는 다양한 키에 대응하는 해시 값들이 저장되어있다. 각 해시 값은 해당 키에 대한 데이터를 검색하는데 사용된다.

## 헤시맵의 삽입, 검색, 삭제연산

**삽입(Insert)**

- 헤시맵에 특정 키-값 쌍을 추가할 때, 해당 키를 헤시 함수를 사용하여 헤시 값으로 변환하고, 해당 헤시 값을 인덱스로 사용하여 새로운 키-값을 저장한다.

**검색**

- 주어진 키를 검색할 때, 해당 키를 해시 함수를 사용하여 해시 값으로 변환하고, 해당 해시 값이 인덱스로 사용되어 슬롯에서 해당 키-값 쌍을 검색한다.

**삭제**

- 주어진 키를 사용하여 해당 키-값 쌍을 헤시맵에서 제거한다.

## 헤시맵의 성능과 사용 사례

- 헤시맵은 빠른 데이터 검색이 필요한 상황에서 주로 사용된다.
- 성능은 해시 함수의 품질, 충돌 해결전략, 헤시맵 크기 및 _로드 팩터_(데이터와 버킷의 비율)에 따라 달라질수 있다.
- 사용 사례에 따라 다양한 헤시 함수 및 충돌 처리 전략을 선택할 수 있으며 데이터를 효율적으로 관리하기 위해 사용

## 헤시 테이블과 버킷구조

- 헤시 테이블은 데이터를 저장하는 데 사용되는 자료 구조로 , 일반적으로 해시 함수를 사용하여 데이터를 인덱싱한다.
- 버킷은 헤시 테이블 내부의 슬롯으로 생각 할 수 있고, 각 버킷은 일련의 데이터를 저장한다.
- 버킷은 헤시 함수에 따라 데이터가 저장되는 위치로 같은 헤시 값을 가진 데이터는 동일한 버킷에 저장된다.

## 헤시 셋(HashSet)과 헤시맵(HashMap)의 차이점

- 헤시셋은 값만을 저장하는 데이터 구조로 , 각 값은 헤시 함수를 사용하여 헤시 값으로 변환되고, 중복된 값은 저장되지 않는다.
- 헤시맵은 키-값쌍을 저장하는 데이터 구조로 각 키는 헤시 함수를 사용하여 헤시 값으로 변환되고 해당 헤시 값을 사용하여 값에 접근합니다.

## 헤시 함수의 품질과 안정성

- 헤시 함수의 품질은 중요하다. 좋은 헤시 함수는 서로 다른 입력에 대해 다른 헤시 값을 생성하고 헤시 충돌을 최소화해야한다.
- 안전한 헤시 함수는 헤시값의 민감도를 줄이고, 랜덤한 입력에 대해 예측이 어려워야한다. **이는 보안 관련 용도에서 중요하다.**

## 자바스크립트에서의 Map과 Object 의 차이점

### Map:

- Map은 일반적으로 다양한 자료형을 키로 사용할 수 있다.
- 삽입 순서를 보장하므로 항상 키-값 쌍을 추가한 순서대로 접근할 수 있다.
- 크기를 나타내는 size 프로퍼티를 제공한다.
- 특정 키-값 쌍을 삭제하거나 모든 항목을 한 번에 삭제할 수 있는 메서드를 제공한다.
- 반복 및 이터레이션을 위한 다양한 메서드 및 이터레이터를 지원한다.

### 객체(Object):

- 객체는 주로 문자열 또는 심볼 키를 사용하여 데이터를 저장하고 관리한다.
- 삽입 순서를 보장하지 않는다.
- 크기를 나타내는 내장 프로퍼티가 없으며, 크기를 확인하려면 직접 계산해야 한다.
- 특정 키(Key)에 대한 값을 삭제할 수 있지만, 모든 항목을 삭제하는 메서드가 없다.
- 반복을 위해 for...in 구문을 사용하거나, Object.keys(), Object.values(), Object.entries() 등의 메서드를 활용한다.

> 둘다 키-값 쌍을 저장하고 검색하는 데 사용될 수 있으므로 일반적으로 해시맵으로 간주할수 있다.
> 하지만 Map은 더 많은 기능과 유연성을 제공하고 , 다양한 자료형의 키와 순서를 보장할 필요가 있는 경우에는 Map을
> 사용하는 것이 좋다. 객체는 주로 문자열 또는 심볼 키와 더 단순한 데이터 구조에 사용된다.

## 사용예시 Map

### 기본 js 코드

```js
// 빈 Map 생성
const myMap = new Map();

// 키-값 쌍 추가
myMap.set("apple", 10);
myMap.set("banana", 20);
myMap.set("cherry", 15);

// 값 조회
console.log(myMap.get("apple")); // 10
console.log(myMap.get("banana")); // 20

// Map 크기 확인
console.log(myMap.size); // 3

// Map 순회
myMap.forEach((value, key) => {
  console.log(key, value);
});

// 또는
for (const [key, value] of myMap.entries()) {
  console.log(key, value);
}

// 특정 키-값 쌍 삭제
myMap.delete("banana");

// 키의 존재 여부 확인
console.log(myMap.has("cherry")); // true
console.log(myMap.has("banana")); // false

// 모든 항목 삭제
myMap.clear();
```

### 활용

- 복잡한 데이터 구조 관리: 데이터가 중첩된 구조 또는 여러 계층으로 구성되어 있는 경우 Map을 사용하여 데이터를 더 효과적으로 조작하고 관리할 수 있다.

- 중복된 항목 검사: 중복된 항목을 효과적으로 관리하려면 Map을 사용하여 각 항목을 키로 저장하고 중복을 방지할 수 있다.

- 캐시 관리: 캐시 메커니즘을 구현할 때 Map을 사용하여 결과를 저장하고 나중에 재사용할 수 있다.

- 데이터 필터링 및 조작: 데이터를 필터링하거나 변환할 때 Map을 사용하여 데이터를 효과적으로 조작할 수 있다.

- 데이터 표현: 데이터를 키-값 쌍으로 표현하거나 연결된 데이터를 표현할 때 Map을 사용할 수 있다.

- 효율적인 데이터 검색: Map을 사용하여 특정 키에 대한 값을 빠르게 검색할 수 있다
