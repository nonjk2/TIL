- [WebSocket](#websocket)
  - [1. 웹소켓 개요](#1-웹소켓-개요)
    - [웹소켓의 역할과 특징 소개](#웹소켓의-역할과-특징-소개)
    - [웹소켓의 장점과 사용 사례](#웹소켓의-장점과-사용-사례)
  - [2. 웹소켓 프로토콜](#2-웹소켓-프로토콜)
    - [웹소켓 프로토콜의 동작 원리](#웹소켓-프로토콜의-동작-원리)
    - [HTTP와의 차이점 및 호환성](#http와의-차이점-및-호환성)
  - [3. 웹소켓 통신 방식](#3-웹소켓-통신-방식)
    - [클라이언트와 서버 간의 웹소켓 연결 설정](#클라이언트와-서버-간의-웹소켓-연결-설정)
    - [메시지 전송과 수신 방법](#메시지-전송과-수신-방법)
    - [이벤트 핸들링과 콜백 함수 등의 사용 방법](#이벤트-핸들링과-콜백-함수-등의-사용-방법)
  - [4. 웹소켓 프레임워크 및 라이브러리](#4-웹소켓-프레임워크-및-라이브러리)
  - [5. 보안과 웹소켓](#5-보안과-웹소켓)
    - [웹소켓 보안 취약점과 대응 방법](#웹소켓-보안-취약점과-대응-방법)
    - [SSL/TLS 적용 및 인증 방법](#ssltls-적용-및-인증-방법)
  - [6. 웹소켓 확장 기능](#6-웹소켓-확장-기능)
    - [하트비트 메시지와 연결 유지 기능](#하트비트-메시지와-연결-유지-기능)
    - [프로토콜 확장과 사용자 정의 메시지 형식](#프로토콜-확장과-사용자-정의-메시지-형식)
  - [7. 웹소켓과 다른 통신 방식 비교](#7-웹소켓과-다른-통신-방식-비교)
    - [웹소켓(WebSockets)](#웹소켓websockets)
    - [HTTP Long Polling](#http-long-polling)
    - [Server-Sent Events (SSE)](#server-sent-events-sse)

# WebSocket

## 1. 웹소켓 개요

- 웹소켓은 **실시간 양방향 통신을 위한 프로토콜**.
- 웹 애플리케이션에서 서버와 클라이언트 간의 **지속적인 연결**을 제공.
- 기존의 HTTP 프로토콜과 달리, 웹소켓은 연결을 유지하고 **양방향**으로 데이터를 주고받을 수 있다.
- **실시간 채팅, 실시간 업데이트, 알림 기능** 등에 주로 사용할수 있음.

### 웹소켓의 역할과 특징 소개

- `실시간 통신`: 웹소켓은 서버와 클라이언트 간의 실시간 양방향 통신을 제공합니다. 데이터의 전송이 즉시 이루어지며, 서버 또는 클라이언트에서 언제든지 데이터를 보낼 수 있습니다.

    <br>

- `단일 연결`: 웹소켓은 클라이언트가 서버와 단일 연결을 유지합니다. 이를 통해 **오버헤드를 줄이고 빠른 통신을 가능**하게 합니다.

    <br>

- `저전력 및 효율성`: 웹소켓은 연결이 유지되는 동안 데이터를 주고받을 수 있으므로, **HTTP의 요청-응답 방식보다 효율적이고 저전력**입니다.

    <br>

- `확장 가능성`: 웹소켓은 프로토콜 확장을 통해 사용자 정의 메시지 형식이나 기능을 추가할 수 있습니다.

### 웹소켓의 장점과 사용 사례

- `실시간 통신`: 웹소켓을 사용하면 서버에서 클라이언트로 실시간 데이터를 전송할 수 있습니다. 이를 통해 실시간 채팅, 주식 시세 업데이트, 실시간 게임 등 다양한 실시간 애플리케이션을 개발할 수 있습니다.
  <br>
- `효율적인 통신`: 웹소켓은 연결을 유지하고 있기 때문에 HTTP의 요청-응답 방식보다 더 효율적인 통신을 할 수 있습니다. 불필요한 연결 설정과 해제를 줄여서 네트워크 부하를 감소시킵니다.
  <br>
- `단일 연결 관리`: 웹소켓은 단일 연결을 유지하기 때문에 서버 측에서 연결의 상태를 간단하게 관리할 수 있습니다. 이를 통해 서버 부하를 줄이고 확장성을 향상시킬 수 있습니다.
  <br>

## 2. 웹소켓 프로토콜

- 웹소켓 프로토콜은 웹소켓 통신을 위한 표준 프로토콜로, HTTP와는 다른 독립적인 프로토콜입니다.
- 웹소켓 프로토콜은 TCP/IP 기반의 연결을 사용하여 클라이언트와 서버 간의 양방향 통신을 제공합니다.

### 웹소켓 프로토콜의 동작 원리

- `핸드쉐이크 (Handshake)`: 클라이언트가 서버에 웹소켓 연결을 요청하면, 서버는 HTTP Upgrade 요청을 받아들여 웹소켓 연결로 전환합니다. 이 과정을 핸드쉐이크라고 합니다.
  <br>
- `연결 설정 (Connection Establishment)`: 핸드쉐이크 후에 클라이언트와 서버는 웹소켓 연결을 설정하고, 서로 데이터를 주고받을 수 있는 상태가 됩니다.

    <br>

- `양방향 통신 (Bidirectional Communication)`: 연결이 설정된 후에는 클라이언트와 서버가 양방향으로 데이터를 주고받을 수 있습니다. 양측은 데이터를 프레임(frame) 단위로 전송하고, 상대방은 해당 프레임을 수신하여 처리합니다.
- ![사진](./websocket/image/Websocket_connection.png)

- 정리
  1. 클라이언트는 웹소켓 엔드포인트로 HTTP 요청을 보냅니다.
  2. 백엔드 서버는 해당 요청을 받아들이고, 웹소켓 핸드쉐이크(handshake)를 시작합니다.
  3. 백엔드 서버는 클라이언트에게 HTTP 101 Switching Protocols 응답을 보냅니다. 이 응답은 웹소켓 프로토콜로의 전환을 나타냅니다. 이때, HTTP 업그레이드가 발생합니다.
  4. 클라이언트와 서버 간에 웹소켓 연결이 설정됩니다. 이제 양방향 통신이 가능하며, 실시간 데이터 교환을 위해 사용될 수 있습니다.

### HTTP와의 차이점 및 호환성

- 웹소켓은 기존의 HTTP 프로토콜과는 다른 프로토콜이지만, 웹소켓 연결을 설정하기 위해 초기에는 HTTP 프로토콜을 사용합니다.

    <br>

- 웹소켓 연결 요청 시에는 HTTP Upgrade 요청을 통해 연결을 전환합니다.

    <br>

- 웹소켓 연결이 설정된 후에는 독립적인 프로토콜로 동작하며, HTTP와는 별개로 데이터를 주고받을 수 있습니다.

## 3. 웹소켓 통신 방식

### 클라이언트와 서버 간의 웹소켓 연결 설정

- 클라이언트는 서버에 웹소켓 연결을 요청합니다. 이를 위해 클라이언트는 웹소켓 URL을 사용하여 서버에 접속합니다.
- 서버는 클라이언트의 연결 요청을 받아들이고, 핸드쉐이크 과정을 통해 웹소켓 연결을 설정합니다.
- 연결 설정이 완료되면, 클라이언트와 서버 간에 양방향 통신이 가능한 상태가 됩니다.

### 메시지 전송과 수신 방법

- 클라이언트와 서버는 연결이 설정된 후, 양측 모두에서 메시지를 전송하고 수신할 수 있습니다.
- 클라이언트는 `send()` 메서드를 사용하여 서버로 메시지를 전송할 수 있습니다.
- 서버는 메시지를 수신하기 위해 클라이언트로부터 메시지 이벤트를 기다리고, 수신된 메시지를 처리할 수 있습니다.
- 메시지는 일반 텍스트 형식 또는 바이너리 형식으로 전송할 수 있으며, 양측은 이를 해석하여 처리합니다.

### 이벤트 핸들링과 콜백 함수 등의 사용 방법

- 웹소켓은 다양한 이벤트를 처리하기 위해 이벤트 핸들링과 콜백 함수를 사용합니다.
- 클라이언트와 서버는 각각 이벤트 핸들러를 등록하여 특정 이벤트가 발생했을 때 원하는 동작을 수행할 수 있습니다.
- 예를 들어, 클라이언트는 `onopen` 이벤트 핸들러를 등록하여 연결이 성공적으로 열렸을 때 특정 동작을 수행할 수 있습니다.
- 서버는 `onmessage` 이벤트 핸들러를 등록하여 클라이언트로부터 메시지가 도착했을 때 처리할 수 있습니다.
- 이외에도 연결이 닫혔을 때(`onclose`), 에러가 발생했을 때(`onerror`) 등 다양한 이벤트를 처리할 수 있습니다.

## 4. 웹소켓 프레임워크 및 라이브러리

- **Socket.IO**
  Socket.IO는 실시간 웹 어플리케이션 개발을 위한 JavaScript 라이브러리입니다.
  양방향 통신을 위한 웹소켓을 기반으로 동작하며, 폴링 및 폴링 대체 기술도 지원합니다.
  다양한 플랫폼 (Node.js, JavaScript, Python 등)에서 사용할 수 있습니다.

  <br>

- **SignalR**
  SignalR은 실시간 웹 애플리케이션 개발을 위한 ASP.NET 라이브러리입니다.
  웹소켓을 비롯한 다양한 통신 기술 (롱 폴링, 서버-센트 이벤트 등)을 지원합니다.
  .NET 기반의 애플리케이션에서 사용할 수 있습니다.

  <br>

- **SockJS**
  SockJS는 웹소켓을 지원하지 않는 브라우저에서도 실시간 양방향 통신을 가능하게 하는 JavaScript 라이브러리입니다.
  웹소켓을 사용할 수 있는 경우 웹소켓을 사용하고, 그렇지 않은 경우 폴링 등의 기술을 사용하여 통신합니다.
  다양한 플랫폼 (Node.js, JavaScript, Python 등)에서 사용할 수 있습니다.

  <br>

- **Atmosphere**
  Atmosphere는 자바 기반의 실시간 웹 애플리케이션 개발을 위한 프레임워크입니다.
  웹소켓을 비롯한 다양한 통신 기술 (롱 폴링, 서버-센트 이벤트 등)을 지원합니다.
  자바 기반의 애플리케이션에서 사용할 수 있습니다.

## 5. 보안과 웹소켓

### 웹소켓 보안 취약점과 대응 방법

1. 크로스 사이트 스크립팅 (Cross-Site Scripting, XSS)

   - **XSS는 악의적인 스크립트를 삽입하여 웹애플리케이션의 취약점을 이용하는 공격입니다**.
   - 웹소켓을 사용할 때는 입력값 검증 및 이스케이프 처리를 통해 XSS 공격을 방지해야 합니다.
   - 서버 측에서도 입력값의 검증과 이스케이프 처리를 수행해야 합니다.

2. 크로스 사이트 요청 위조 (Cross-Site Request Forgery, CSRF):

   - **CSRF는 인증된 사용자를 이용하여 악의적인 요청을 실시하는 공격입니다.**
   - 웹소켓을 사용하는 경우, 적절한 인증 및 권한 체크를 수행하여 CSRF 공격을 방지해야 합니다.
   - 추가적인 보안측에서는 CSRF 토큰을 사용하여 요청의 유효성을 검증할 수 있습니다.

3. 동일 출처 정책 (Same Origin Policy):
   - 웹소켓은 동일 출처 정책을 따릅니다. 즉, 프로토콜, 호스트, 포트가 동일한 출처에서만 통신이 가능합니다.
   - 이를 통해 다른 출처에서의 웹소켓 연결과 데이터 접근을 차단하여 보안을 유지합니다.
   - **만약 다른 출처와의 통신이 필요한 경우, Cross-Origin Resource Sharing (CORS)를 설정**하여 허용할 수 있습니다.

### SSL/TLS 적용 및 인증 방법

웹소켓 통신의 보안을 강화하기 위해 SSL/TLS (Secure Sockets Layer/Transport Layer Security) 프로토콜을 적용할 수 있습니다. SSL/TLS를 통해 통신 과정에서 데이터의 암호화와 인증을 제공할 수 있습니다. SSL/TLS를 적용하는 방법은 다음과 같습니다:

1. SSL/TLS 인증서 획득:

   - SSL/TLS 인증서는 인증된 기관에서 발급받아야 합니다. 일반적으로 SSL/TLS 인증서는 유료로 제공되지만, Let's Encrypt와 같은 무료 인증 기관도 있습니다.

2. 웹서버 설정:

   - 웹서버 (예: Apache, Nginx)에서 SSL/TLS 인증서를 설정해야 합니다.
   - 인증서 파일과 개인 키 파일을 웹서버에 등록하고, 웹서버의 설정 파일을 수정하여 HTTPS로의 연결을 허용하도록 설정합니다.

3. 웹소켓 연결 설정:
   - 클라이언트와 서버의 웹소켓 연결 시에는 `wss://` 프로토콜을 사용하여 암호화된 연결을 설정합니다.
   - 클라이언트 및 서버에서 SSL/TLS 인증서의 유효성을 검증해야 합니다.

SSL/TLS를 적용하면 웹소켓 통신이 암호화되어 데이터의 안전성과 개인정보 보호를 강화할 수 있습니다. SSL/TLS 인증서의 획득과 웹서버, 웹소켓 연결의 설정을 통해 보다 안전한 통신 환경을 구축할 수 있습니다.

## 6. 웹소켓 확장 기능

### 하트비트 메시지와 연결 유지 기능

- 하트비트 메시지는 주기적으로 클라이언트와 서버 간에 교환되는 메시지입니다.
  이 메시지는 연결이 유지되고 있는지 확인하고, 연결이 끊어지지 않도록 유지하는 역할을 합니다.
  클라이언트는 일정한 간격으로 서버에 하트비트 메시지를 보내고, 서버는 이를 수신하여 연결 상태를 확인합니다.
  만약 일정 시간 동안 하트비트 메시지를 수신하지 못하면, 서버는 연결이 끊어졌다고 간주하고 적절한 조치를 취할 수 있습니다.

### 프로토콜 확장과 사용자 정의 메시지 형식

- **웹소켓 프로토콜**은 기본적으로 텍스트 또는 바이너리 형식의 메시지를 주고받을 수 있습니다. 그러나 프로토콜을 확장하여 사용자 정의 메시지 형식을 지원할 수도 있습니다. 이를 통해 클라이언트와 서버 간에 특정 형식의 메시지를 주고받을 수 있으며, 이를 활용하여 특정한 요구사항에 맞는 데이터 교환을 구현할 수 있습니다. 예를 들어, JSON 형식의 메시지를 사용하여 구조화된 데이터를 주고받을 수 있습니다.

프로토콜 확장은 일반적으로 사용자 정의 메시지 형식을 정의하고, 클라이언트와 서버 간의 약속된 규칙에 따라 해당 메시지를 처리하는 로직을 구현하는 것을 포함합니다.

## 7. 웹소켓과 다른 통신 방식 비교

### 웹소켓(WebSockets)

- 장점:
  - 실시간 양방향 통신이 가능하며, 서버와 클라이언트 간에 작은 오버헤드로 빠른 데이터 전송이 가능합니다.
  - 서버에서 클라이언트로 데이터를 푸시(push)할 수 있어 실시간 업데이트가 필요한 애플리케이션에 적합합니다.
  - 단일 연결로 여러 메시지를 교환할 수 있어, 연결 유지 및 관리에 대한 부담이 적습니다.
- 단점:
  - 웹소켓을 지원하지 않는 환경에서는 사용할 수 없습니다.
  - 일부 프록시 서버나 방화벽에서 웹소켓 연결을 차단할 수 있습니다.

적합한 사용 사례:

- 실시간 채팅 애플리케이션
- 실시간 협업 도구
- 실시간 주식 시세 업데이트
- 실시간 게임

### HTTP Long Polling

- 장점:
  - 대부분의 웹 브라우저에서 지원되는 표준 HTTP 프로토콜을 사용합니다.
  - 서버에서 클라이언트로 데이터를 푸시(push)할 수 있습니다.
- 단점:
  - 서버에 많은 동시 연결이 발생하여 서버 부하가 증가할 수 있습니다.
  - 클라이언트가 주기적으로 새로운 연결을 생성해야 하므로, 오버헤드가 발생할 수 있습니다.

적합한 사용 사례:

- 실시간 업데이트가 필요한 애플리케이션
- 알림 기능이 필요한 애플리케이션

### Server-Sent Events (SSE)

- 장점:
  - 서버에서 클라이언트로 단방향 데이터 스트리밍이 가능합니다.
  - 표준 HTTP 프로토콜을 사용하며, 대부분의 최신 웹 브라우저에서 지원됩니다.
- 단점:
  - 실시간 양방향 통신이 아니므로, 클라이언트에서 서버로 메시지를 전송할 수 없습니다.
  - 오래된 브라우저에서는 지원되지 않을 수 있습니다.

적합한 사용 사례:

- 실시간 업데이트가 필요한 애플리케이션
- 뉴스 피드, 주식 시세 등의 실시간 스트리밍 데이터
