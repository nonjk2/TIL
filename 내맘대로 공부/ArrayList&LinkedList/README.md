# Array List

- 배열은 JavaScript에서 데이터를 순서대로 저장하는 데이터 구조다.
- 배열은 여러 데이터 항목을 담을 수 있으며, 각 항목은 고유한 인덱스를 가지고 있다.
- 배열은 대괄호 []로 정의되며, 배열 내의 각 항목은 콤마 , 로 구분된다

```js
const study = ["은석", "채원", "민승", "도원"];
```

위 코드에서 `study`는 배열 변수고 , 배열 안에는 네명의 스터디원이름이 저장 되어있다.
각 항목은 쉼표로 구분하며 배열은 대괄호로 둘러싸여 있다.

배열은 여러 데이터 유형을 혼합해서 저장할수 있고 인덱스를 사용해서 각 항목에 접근할 수 있다.
인덱스는 0부터 시작하며 첫번 째 항목은 인덱스 0 , 두번 째 항목은 인덱스 1, 그리고 이어서 증가한다.

## cs에서의 배열

    컴퓨터 과학에서 배열은 동일한 데이터 유형의 요소 즉 데이터 항목을 순서대로 저장하는 선형 데이터 구조이다.
    배열은 메모리에서 연속된 위치에 데이터를 저장하며 , 각 요소를 고유한 인덱스를 갖고있다.

### 특징

    1. 인덱싱 : 각 요소는 0부터 시작하는 인덱스로 식별된다.

    2. 고정크기 : 대부분의 언어에서 배열은 생성 시 크기를 정의하고 , 일반적으로 크기를 변경하지않는다. 이것을 정적 배열이라고 한다. (Static Array)

    3. 동적 배열 : 몇몇 언어에서는 크기를 동적으로 변경할 수 있는 배열을 제공한다. 이를 동적 배열(dynamic array) 라고 한다.

    4. 메모리 효율성 : 배열은 연속된 메모리 위치에 요소를 저장하므로 인덱스를 사용해서 빠르게 요소에 접근할 수 있다. 이것은 메모리 효율적인 데이터 구조이다.

    5. **검색과 삽입** : 배열의 검색은 빠르지만 삽입과 삭제는 배열 중간에 요소를 추가하거나 제거할 때 다소 비효율적일 수 있다.

    6. 다차원 배열 : 배열은 다차원으로 확장할 수 있고, 다차원 배열은 행렬과 같은 구조를 나타내는 데 사용된다.

> 배열에서 특정 인덱스에 있는 요소를 읽는 작업은 매우 효율적이다.
> 이유는 배열의 각 요소가 메모리에서 연속적으로 저장되어 있기 때문인데 원하는 인덱스의 요소를
> 직접 접근하면 CPU가 해당 메모리 위치로 빠르게 이동하여 데이터를 읽을 수 있다.
> 이는 상수 시간(O(1))에 가능하므로 배열에서 요소를 읽는 작업은 빠르다.

#### 배열조회단점

> **그러나 배열에서 요소를 중간에 삽입하거나 삭제할 때는 상황이 다르다.**
> 이러한 작업은 특정 인덱스 이후의 모든 요소를 이동해야 하기 때문에 시간과 리소스를 많이 소모할 수 있다. 그이유를 살펴보자
>
> 1. **데이터 이동** : 요소를 삽입하거나 삭제할 때, 해당 인덱스 이후의 모든 요소를 이동 해야한다. 이작업은 배열의 크기와 데이터 양에 따라 선형 시간(O(n))이 소요된다.
> 2. **메모리 재배열** : 배열은 메모리 상에 연속적으로 저장되어야 하므로, 삽입 또는 삭제 작업으로 배열의 물리적 메모리 위치가 변경될 수 있다.따라서 메모리를 재배열하고 데이터를 복사해야 하는 추가 오버헤드가 발생할 수 있다.
> 3. **인덱스의 업데이트** : 삽입 또는 삭제로 인해 인덱스가 변경되어야 할 수도 있고 , 이로인해서 다른 요소의 인덱스도 업데이트 되야한다.

## 배열 접근

배열에서 항목에 접근하려면 다음과 같이 인덱스를 사용.

```js
const firststudy = study[0]; // 첫 번째 항목에 접근 '은석'
const secondstudy = study[1]; // 두 번째 항목에 접근 '채원'
```

### 인덱스

배열에서 인덱스는 배열 내의 각 요소에 접근하고 식별하는 역할이다.
인덱스는 배열 요소를 식별하는데 사용되고 , 배열의 첫 번째 요소부터 시작하여 0부터 증가하는 정수 값으로 표현된다.

- 요소식별
- 요소 수정 및 업데이트
  - 인덱스를 사용해서 배열 내의 특정 요소의 값을 변경하거나 업데이트 할 수 있다. (수정 및 관리)
- 반복 및 루프
  - 반복문을 사용해서 배열 내의 모든 요소를 순회할 때 인덱스를 활용 (조회)
- 검색 및 탐색
  - 특정 값이 배열 내에 있는지 확인하고 해당 값이 어느 인덱스 위치하는지 확인하는데 인덱스를 사용할수 있다.
- 정렬 및 필터링
  - 배열 요소를 정렬하거나 특정 조건을 충족하는 요소를 필터링할때 인덱스가 유용

## JavaScript에서의 배열 메소드

많은 배열 메소드와 배열 순회와 반복 등이 있는데 다 살펴보자
for

### for of , for루프

```js
const study = ["은석", "채원", "민승", "도원"];
```

#### for루프

```js
for (let i = 0; i < study.length; i++) {
  console.log(study[i]);
}
```

#### for...of

```js
for (const studyOne of study) {
  console.log(fruit);
}
```

### 배열 메서드

자바스크립트에서 사용하는 배열 메서드들을 정리

- push(): 배열의 끝에 요소를 추가합니다.
- pop(): 배열의 끝에서 요소를 제거하고 반환합니다.
- shift(): 배열의 시작에서 요소를 제거하고 반환합니다.
- unshift(): 배열의 시작에 요소를 추가합니다.
- concat(): 배열을 병합하여 새로운 배열을 생성합니다.
- join(): 배열 요소를 문자열로 합칩니다.
- slice(): 배열의 일부를 추출하여 새로운 배열을 생성합니다.
- splice(): 배열에서 요소를 추가, 제거 또는 교체합니다.
- map(): 배열의 각 요소를 변환하여 새로운 배열을 생성합니다.
- filter(): 주어진 조건을 만족하는 요소로 새로운 배열을 생성합니다.
- reduce(): 배열 요소를 하나의 값으로 축소합니다.
- forEach(): 배열의 각 요소에 대해 반복 작업을 수행합니다.
- find(): 주어진 조건을 만족하는 첫 번째 요소를 반환합니다.
- findIndex(): 주어진 조건을 만족하는 첫 번째 요소의 인덱스를 반환합니다.
- every(): 모든 요소가 주어진 조건을 만족하는지 검사합니다.
- some(): 하나 이상의 요소가 주어진 조건을 만족하는지 검사합니다.
- sort(): 배열을 정렬합니다.
- reverse(): 배열의 순서를 역순으로 바꿉니다.
- includes(): 특정 요소가 배열에 포함되어 있는지 검사합니다.
- indexOf(): 특정 요소의 첫 번째 인덱스를 반환하며, 요소가 없을 경우 -1을 반환합니다.
- lastIndexOf(): 특정 요소의 마지막 인덱스를 반환하며, 요소가 없을 경우 -1을 반환합니다.

# Linked List

링크드리스트는 데이터를 순서대로 저장하는 선형 데이터 구조로, 각 요소는 노드(Node)로 표현되며, 각 노드는
데이터 필드와 다음 노드를 가리키는 링크(또는 포인터)로 구성된다. 링크드 리스트의 핵심 원리는 데이터를 연결된 노드들로 표현하여 서로 연결하는 것이다.
![리스트](링크드리스트%20어레이리스트.png)

[배열리스트단점](#배열조회단점)에서 설명한것처럼 추가 혹은 삭제의 단점을 보완한 리스트
하지만 조회가 Array List 보다 느리다

## 링크드 리스트 두가지

### 단일 링크드 리스트

- 단일 링크드 리스트는 각 노드가 데이터 필드와 다음 노드를 가리키는 링크로 구성된다.
- 각 노드는 데이터 필드와 다음 노드를 가리키는 링크로 이루어져 있다.
- 노드는 다음 노드를 가리키므로 한 방향으로만 순회할 수 있다. 즉, 다음 노드로 이동하는 방향으로만 이동이 가능하다.

### 이중 링크드 리스트

- 이중 링크드 리스트는 각 노드가 데이터 필드, 다음 노드를 가리키는 링크, 그리고 이전 노드를 가리키는 링크로 구성된다.
- 각 노드는 데이터 필드, 다음 노드를 가리키는 링크, 이전 노드를 가리키는 링크로 이루어져 있다.
- 노드는 다음 노드와 이전 노드를 모드 가리키므로 , 양방향으로 순회할 수 있다. 이것은 이전 노드로도 이동이 가능하다는 의미이다.

> **각 링크드리스트 차이와 특징**
>
> - 단일 링크드 리스트 : 각 노드는 다음 노드만 가리킴 단방향 순회만 가능.
> - 이중 링크드 리스트 : 각 노드는 다음 노드와 이전 노드를 모두 가리킴 . 양방향 순회 가능
>
> 이중 링크드 리스트는 더 많은 메모리를 사용해서 노드를 수정하는데 더 복잡한 작업을 필요로한다. 하지만 양방향 순회가 가능해 특정 상황에서 유용하다.
>
> 단일 링크드 리스트는 메모리 사용량이 적고 간단하지만, 뒤로 거슬로 올라가거나 이전 노드에 접근하는 것이 어려울 수 있다.

## 링크드 리스트의 삽입, 삭제, 검색연산

### 삽입(Insertion)

- 노드 삽입: 원하는 위치에 새로운 노드를 삽입한다.
- 노드 앞에 삽입: 새로운 노드를 앞쪽(첫 번째 노드)에 삽입할 때는 다음 노드를 새로운 노드의 다음 노드로 설정하고, 첫 번째 노드를 새로운 노드로 대체한다.
- 노드 뒤에 삽입: 새로운 노드를 중간이나 마지막에 삽입할 때는 새로운 노드의 다음 노드를 다음 노드로 설정하고, 이전 노드의 다음 노드를 새로운 노드로 설정한다.

### 삭제(Deletion)

- 노드 삭제: 특정 노드를 삭제할 때는 이전 노드의 다음 노드를 삭제할 노드의 다음 노드로 설정한다. 삭제할 노드는 링크드 리스트에서 분리.

### 검색(Search):

- 노드 검색: 링크드 리스트를 순회하면서 특정 데이터를 가진 노드를 찾을 수 있다. 시작 노드부터 순회하며 검색하고, 원하는 데이터를 찾으면 해당 노드를 반환하거나 위치를 반환할 수 있다.

## 링크드 리스트 순회 및 반복

링크드 리스트를 순회하려면 시작 노드에서 부터 시작해서 다음 노드로 이동하면서 노드의 데이터를 처리하고 다음 노드로 이동하는 과정을 반복한다. 반복문 또는 재귀적 방법으로 순회할 수 있다.

예)

```js
function traverseLinkedList(head) {
  let current = head; // 시작 노드
  while (current !== null) {
    // 현재 노드 처리 (예: 출력)
    console.log(current.data);
    current = current.next; // 다음 노드로 이동
  }
}
```

위 코드에서 head는 링크드 리스트의 시작 노드를 나타내고, current 변수를 사용하여 노드를 순회한다. 링크드 리스트의 끝에 도달하면 current가 null이 되어 순회를 종료한다.

링크드 리스트의 순회는 링크드 리스트 내의 모든 데이터에 접근하는데 사용된다.

**링크드 리스트는 데이터를 동적으로 삽입하고 삭제하기에 적합**하며, 링크드 리스트를 순회하여 데이터를 처리하는 것은 많은 데이터 구조 및 알고리즘에서 중요한 부분이다.

## 링크드 리스트와 Array List(배열)의 비교

> **메모리 사용** > `배열`은 연속적인 메모리를 사용하므로 메모리 효율적이다.
> `링크드 리스트`는 각 노드가 독립적인 메모리 공간을 사용하므로 메모리 오버헤드가 발생할 수 있다.
>
> **접근 시간** > `배열`은 인덱스를 사용하여 상수 시간(O(1))에 요소에 접근할 수 있다.
> `링크드 리스트`는 순회해야 하므로 선형 시간(O(n))이 소요될 수 있다.
>
> **삽입 및 삭제 시간** > `배열`은 중간에 요소를 삽입 또는 삭제할 때 비효율적일 수 있다.
> `링크드 리스트`는 삽입 및 삭제가 간단하며 일반적으로 상수 시간이 소요된다.
>
> **크기 변경** > `배열`의 크기를 동적으로 변경하기 어려울 수 있으며, 크기 변경 시 메모리 재할당이 필요하다.
> `링크드 리스트`는 동적으로 크기를 조절할 수 있다.
>
> **용도** > `배열`은 빠른 접근이 필요한 경우에 적합하며
> `링크드 리스트`는 동적인 데이터 구조 또는 삽입/삭제 작업이 빈번한 경우에 유용하다.
