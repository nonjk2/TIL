# Restful api

RESTful API는 _Representational State Transfer(REST)_ 아키텍처 스타일을 따르는 API 디자인의 한 형태다. RESTful API는 웹 리소스를 사용하고 HTTP 프로토콜을 통해 데이터를 전송하는 방식을 중심으로 한다. 여기에서 "리소스"는 데이터 또는 서비스를 나타내며, 각 리소스는 고유한 식별자(URI)를 가지고 있다.

> **Re**presentational(표현) **S**tate(상태) **T**ransfer(전달)
> 자원을 이름으로 구분하여 자원의 상태를 전달

### 주요 개념:

1. **자원 (Resource):**

   - RESTful API의 핵심은 자원이다. 모든 것을 자원으로 간주하고, 각 자원은 고유한 URI를 가지고 있다. 예를 들어, 블로그 앱에서 "게시물"이나 "사용자"는 각각 하나의 자원이 될 수 있다.
   - URI ('/seoulvival/123')

2. **표현 (Representation):**

   - 자원의 상태는 여러 형태로 표현될 수 있다. 흔히 사용되는 표현 형식은 JSON 또는 XML이다. 클라이언트는 요청 시 어떤 표현 형식을 원하는지 지정할 수 있고, 서버는 해당 형식으로 응답한다.

3. **상태 전이 (Stateless):**

   - RESTful API는 상태를 유지하지 않고 요청 간의 상태 전이를 달성한다. 각 요청은 필요한 정보를 포함하고 있어야 하며, 서버는 해당 요청을 처리하고 응답을 전송한다. 이렇게 함으로써 서버는 클라이언트의 상태를 알 필요가 없다.

4. **URI (Uniform Resource Identifier):**

   - 모든 자원은 고유한 식별자를 가지며, 이를 통해 클라이언트는 원하는 자원을 명확하게 식별할 수 있다. URI는 자원의 위치를 나타내기 위해 사용된다.

5. **HTTP 메서드 (Methods):**

   - HTTP 프로토콜의 다양한 메서드(GET, POST, PUT, DELETE 등)를 사용하여 자원을 다룹니다. 예를 들어, GET은 자원을 조회하고, POST는 새로운 자원을 생성하며, PUT은 기존 자원을 갱신하고, DELETE는 자원을 삭제한다.

6. **Representation State Transfer (REST):**
   - 클라이언트와 서버 간의 통신은 상태 전이를 통해 이루어집니다. 서버는 자원의 상태를 클라이언트에게 전달하고, 클라이언트는 이를 통해 다음 동작을 결정한다.

### 예시:

1. **자원 (Resource):**

   - `https://api.example.com/posts/123`은 ID가 123인 게시물 자원을 나타냅니다.

2. **표현 (Representation):**

   - 요청헤더
     - text/html, image/gif , text/\*
   - 게시물 자원은 JSON 형식으로 표현될 수 있습니다.
     ```json
     {
       "id": 123,
       "title": "RESTful API 설명",
       "content": "RESTful API는 ...",
       "author": "John Doe"
     }
     ```

3. **HTTP 메서드 (Methods):** (행위 , 상태)
   - `GET /posts/123`: ID가 123인 게시물을 조회한다.
   - `POST /posts`: 새로운 게시물을 생성한다.
   - `PUT /posts/123`: ID가 123인 게시물을 갱신한다.
   - `DELETE /posts/123`: ID가 123인 게시물을 삭제한다.

### 예제

https://developer.mozilla.org/ko/docs/Web/API/Fetch_API/Using_Fetch

### PUT , PATCH

PUT -> 전체 수정 , PATCH -> 부분 수정
팁 : 프론트와 백엔드 간에 약속이라 정해진 틀이없음 전부 PUT을 써도 되고 PATCH를 써도되고 전부 GET을 써도 됨 하지만 가장 중요한것은 상황마다 필요한 메서드를 사용하는것이 베스트다.

HEAD 메서드는 라우터가 존재 하는지 안하는지확인하는 메서드 -> 응답 body를 보내주지않음
OPTIONS : CORS (Cross-Origin Resource Sharing)설정 -> 다른사이트에 요청을 보낼때에 옵션설정을 함
TRACE 메소드는 프록시 서버 추척 + 최종 서버가 받은 메세지를 알려줘서 프록시 서버가 어떤 헤더를 바꿨는지 알 수 있게 함

## Restful API 심화

API 버전 관리는 API가 변화할 때 기존의 클라이언트들이 영향을 받지 않도록 하는 방법이다. 새로운 기능을 도입하거나 기존의 기능을 수정할 때 API를 업데이트하는 것이 일반적인데, 이 과정에서 기존 클라이언트들이 올바르게 동작하지 않을 수 있다 이때문에 버전관리를 하는것이 좋다.

### API 버전 관리:

1. **URI에 버전 포함:**

   - 가장 간단한 방법 중 하나는 URI에 버전을 명시적으로 포함하는 것이다. 예를 들어:
     ```
     https://api.example.com/v1/resource
     https://api.example.com/v2/resource
     ```
   - 이 방법은 간단하지만 URI가 길어지고 복잡해질 수 있다.

2. **헤더 사용:**

   - HTTP 헤더를 사용하여 API 버전을 전달할 수 있다. `Accept` 헤더나 사용자 지정 헤더를 통해 클라이언트가 원하는 API 버전을 명시.

3. **서브도메인 이용:**

   - 서브도메인을 이용하여 API 버전을 나타낼 수 있다.
     ```
     https://v1.api.example.com/resource
     https://v2.api.example.com/resource
     ```

4. **Accept Header 활용:**

   - 클라이언트가 서버에게 요청할 때 `Accept` 헤더에 버전 정보를 포함하여 요청할 수 있다. 서버는 이 정보를 통해 적절한 버전의 응답을 반환한다.

5. **매개변수 사용:**
   - URI의 쿼리 매개변수를 사용하여 API 버전을 전달할 수 있다.
     ```
     https://api.example.com/resource?v=1
     https://api.example.com/resource?v=2
     ```

#### 주의사항:

- **역호환성 유지:**

  - 새로운 버전의 API를 배포할 때는 기존 클라이언트들이 영향을 받지 않도록 역호환성을 유지해야 한다.

- **통일된 방법 선택:**

  - 특정 API에서는 하나의 통일된 방법을 선택하여 사용하는 것이 좋다. 혼합된 버전 관리 방식은 혼란을 야기할 수 있다.

- **문서화:**
  - API 버전 관리에 대한 명확한 규칙을 문서화하여 개발자들이 API를 쉽게 사용할 수 있도록 해야 한다.

### HATEOAS

HATEOAS는 RESTful API에서의 리소스 상태 전이(Representation State Transfer)를 위한 개념으로, 클라이언트가 서버와 상호작용하는 데 필요한 모든 정보를 동적으로 제공하는 아이디어다. HATEOAS는 Hypermedia를 통해 Application State를 전이하는 것을 강조하며, 클라이언트에게 가능한 다음 단계를 안내하는 역할을 한다.

### 핵심 개념:

1. **Hypermedia Controls:**

   - 서버에서 제공되는 응답에는 클라이언트가 다음에 어떤 동작을 수행할 수 있는 하이퍼미디어 컨트롤(링크)이 포함됩니다. 이러한 컨트롤은 클라이언트가 리소스와 상호작용하기 위한 가능한 동작을 정의한다.

2. **동적 상호작용:**
   - 클라이언트는 현재의 리소스 상태를 기반으로 서버로부터 받은 Hypermedia 컨트롤을 이용하여 동적으로 상호작용할 수 있다. 클라이언트는 정적인 API 문서가 아닌, 리소스에 따라 동적으로 상호작용할 수 있다.

#### 예시:

가령, 블로그 글 리소스에 대한 응답이 다음과 같다면:

```json
{
  "id": 123,
  "title": "RESTful API 설명",
  "content": "RESTful API는 ...",
  "author": "John Doe",
  "links": [
    {
      "rel": "self",
      "href": "/api/blog/123"
    },
    {
      "rel": "author",
      "href": "/api/author/456"
    },
    {
      "rel": "comments",
      "href": "/api/blog/123/comments"
    }
  ]
}
```

여기서 `links` 배열은 클라이언트에게 이 리소스와 상호작용할 수 있는 세 가지 링크를 제공한다. 클라이언트는 이를 통해 자신이 필요한 동작을 선택할 수 있다.

#### 장점:

- **자기 설명적인 API:**

  - HATEOAS를 사용하면 API가 자기 설명적이 되어 클라이언트는 더 적은 문서화와 사전 지식이 필요하다.

- **유연성과 확장성:**

  - 서버 측에서 동작이 추가되거나 변경될 경우 클라이언트에 영향을 미치지 않고 유연하게 대처할 수 있다.

- **클라이언트 간 동일한 경험:**
  - 모든 클라이언트가 동일한 Hypermedia 컨트롤을 통해 리소스와 상호작용하므로, 클라이언트 간 일관된 사용자 경험을 제공할 수 있다.

### GraphQL 과 RESTful API

GraphQL과 RESTful API는 각각의 장단점을 가지고 있다. 어떤 기술을 선택할지는 프로젝트의 특정 요구사항과 목적에 따라 달라진다.

#### GraphQL:

##### 1. **단일 요청 및 응답:**

- **장점:** 클라이언트가 필요한 데이터만 요청할 수 있어 불필요한 데이터의 전송을 최소화한다.
- **단점:** Over-fetching 또는 Under-fetching의 문제를 피할 수 있다.

##### 2. **유연성과 강력한 쿼리 언어:**

- **장점:** 클라이언트가 필요한 데이터의 구조를 정의하고, 서버는 해당 구조에 맞게 응답한다.
- **단점:** 서버 사이드에서 복잡한 쿼리를 처리해야 하므로 보안 측면에서 주의가 필요하다.

##### 3. **하나의 엔드포인트:**

- **장점:** 하나의 엔드포인트로 모든 요청을 처리하므로 쿼리의 횟수가 감소하고 네트워크 비용이 감소한다.
- **단점:** 모든 요청에 대한 단일 엔드포인트를 사용하므로 HTTP 캐싱이 어려울 수 있다.

##### 4. **실시간 데이터 및 서브스크립션:**

- **장점:** WebSocket을 통해 실시간 데이터 요청 및 구독이 가능.
- **단점:** 구현 및 관리가 REST에 비해 복잡할 수 있습니다.

#### RESTful API:

##### 1. **단순하고 직관적인 설계:**

- **장점:** 간단하게 이해하고 사용할 수 있으며, HTTP 메서드를 통해 CRUD 작업을 수행합니다.
- **단점:** 필요한 데이터를 모두 가져오는 Over-fetching이 발생할 수 있다.

##### 2. **HTTP 상태 코드 활용:**

- **장점:** HTTP 상태 코드를 통해 간단하게 요청의 성공 또는 실패를 확인할 수 있다.
- **단점:** 세부적인 오류 정보가 부족할 수 있다.

##### 3. **캐싱:**

- **장점:** HTTP 캐싱을 활용하여 불필요한 데이터의 전송을 최소화한다.
- **단점:** 엔드포인트 별로 다른 캐싱 전략을 수립해야 한다.

##### 4. **RESTful 하위 리소스 및 하이퍼링크:**

- **장점:** 하위 리소스 및 하이퍼링크를 통해 리소스 간의 관계를 표현할 수 있다.
- **단점:** 클라이언트가 필요한 데이터를 얻기 위해 여러 번의 요청이 필요할 수 있다.

#### 선택 시 고려 사항:

1. **데이터 구조 및 요청 방식:**

   - GraphQL은 클라이언트가 필요한 데이터를 명시적으로 요청할 수 있어 유연성이 높다.
   - RESTful은 각 엔드포인트마다 정의된 데이터를 반환하므로 클라이언트가 더 적은 제어권을 가진다.

2. **네트워크 성능 및 비용:**

   - GraphQL은 필요한 데이터만 요청하므로 Over-fetching을 방지하고 네트워크 비용을 줄일 수 있다.
   - RESTful은 엔드포인트별로 다른 쿼리를 수행하므로 데이터 양이 많을 경우 Over-fetching이 발생할 수 있다.

3. **개발 생산성:**

   - GraphQL은 클라이언트가 필요한 데이터를 정의하므로 개발 생산성이 향상될 수 있다.
   - RESTful은 간단하고 직관적인 설계로 개발자가 빠르게 익힐 수 있다.

4. **실시간 기능 및 실시간 데이터:**
   - GraphQL은 WebSocket을 통한 실시간 데이터 요청 및 구독을 지원한다.
   - RESTful은 실시간 기능을 제공하기 위해 추가적인 구현이 필요하다.

### 그외 메서드

- **OPTIONS**: 서버에게 특정 리소스에 대한 허용 가능한 메서드를 요청할 때 사용된다. 서버는 이에 대한 응답으로 허용 가능한 메서드들을 제공한다.

  - 다른사이트에 요청을 보낼때 사용된다.
  - - 네트워크탭의 메섣에 POST + preflight 이처럼 보이는게 대부분 **options**에 쓰인다

- **HEAD**: GET 메서드와 유사하지만, 서버는 응답으로 실제 데이터를 반환하지 않고 헤더만 반환한다. 주로 리소스의 메타데이터나 상태를 확인할 때 사용된다.
  - HEAD 메서드는 라우터가 존재 하는지 안하는지확인하는 메서드 -> 응답 body를 보내주지않음
- **TRACE**: 클라이언트가 보낸 요청 메시지를 그대로 돌려받아 디버깅 및 테스트 목적으로 사용된다.
  - TRACE 메소드는 프록시 서버 추척 + 최종 서버가 받은 메세지를 알려줘서 프록시 서버가 어떤 헤더를 바꿨는지 알 수 있게 함
- **CONNECT**: 목적지 서버로의 터널을 만들기 위해 사용되며, 일반적으로 프록시에서 사용된다.

- **LOCK**, **UNLOCK**: 리소스에 대한 락을 걸거나 해제하기 위해 사용된다.

- **COPY**, **MOVE**: 리소스를 복사하거나 이동하기 위해 사용된다.
